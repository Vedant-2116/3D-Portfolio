import {
  CardElement,
  useElements,
  useStripe
} from "./chunk-2Z3NNCL7.js";
import "./chunk-D3UZNAUK.js";
import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/@formspree/core/dist/index.js
var require_dist = __commonJS({
  "node_modules/@formspree/core/dist/index.js"(exports, module) {
    "use strict";
    var b = Object.defineProperty;
    var D = Object.getOwnPropertyDescriptor;
    var j = Object.getOwnPropertyNames;
    var M = Object.prototype.hasOwnProperty;
    var N = (e, t) => {
      for (var r in t)
        b(e, r, { get: t[r], enumerable: true });
    };
    var L = (e, t, r, i) => {
      if (t && typeof t == "object" || typeof t == "function")
        for (let s of j(t))
          !M.call(e, s) && s !== r && b(e, s, { get: () => t[s], enumerable: !(i = D(t, s)) || i.enumerable });
      return e;
    };
    var v = (e) => L(b({}, "__esModule", { value: true }), e);
    var Y = {};
    N(Y, { Client: () => y, createClient: () => g, getDefaultClient: () => A, isFieldError: () => T });
    module.exports = v(Y);
    var p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var B = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    function R(e) {
      e = String(e);
      for (var t, r, i, s, o = "", a = 0, d = e.length % 3; a < e.length; ) {
        if ((r = e.charCodeAt(a++)) > 255 || (i = e.charCodeAt(a++)) > 255 || (s = e.charCodeAt(a++)) > 255)
          throw new TypeError("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.");
        t = r << 16 | i << 8 | s, o += p.charAt(t >> 18 & 63) + p.charAt(t >> 12 & 63) + p.charAt(t >> 6 & 63) + p.charAt(t & 63);
      }
      return d ? o.slice(0, d - 3) + "===".substring(d) : o;
    }
    function I(e) {
      if (e = String(e).replace(/[\t\n\f\r ]+/g, ""), !B.test(e))
        throw new TypeError("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
      e += "==".slice(2 - (e.length & 3));
      for (var t, r = "", i, s, o = 0; o < e.length; )
        t = p.indexOf(e.charAt(o++)) << 18 | p.indexOf(e.charAt(o++)) << 12 | (i = p.indexOf(e.charAt(o++))) << 6 | (s = p.indexOf(e.charAt(o++))), r += i === 64 ? String.fromCharCode(t >> 16 & 255) : s === 64 ? String.fromCharCode(t >> 16 & 255, t >> 8 & 255) : String.fromCharCode(t >> 16 & 255, t >> 8 & 255, t & 255);
      return r;
    }
    var _ = "2.8.1";
    var x = ((o) => (o.REQUIRED_FIELD_MISSING = "REQUIRED_FIELD_MISSING", o.REQUIRED_FIELD_EMPTY = "REQUIRED_FIELD_EMPTY", o.TYPE_EMAIL = "TYPE_EMAIL", o.TYPE_NUMERIC = "TYPE_NUMERIC", o.TYPE_TEXT = "TYPE_TEXT", o))(x || {});
    function T(e) {
      return e.code in x && e.field !== void 0;
    }
    function O(e) {
      return e.errors !== void 0;
    }
    var C = (e) => R(JSON.stringify(e));
    var P = (e) => {
      let t = `@formspree/core@${_}`;
      return e ? `${e} ${t}` : t;
    };
    var w = () => 1 * new Date();
    var u = (e, t, r) => {
      e instanceof FormData ? e.append(t, r) : e = Object.assign(e, { [t]: r });
    };
    var F = async ({ stripePromise: e, response: t, responseData: r, payload: i, data: s, fetchImpl: o, request: a, url: d }) => {
      let c = await e.handleCardAction(r.stripe.paymentIntentClientSecret);
      if (c.error)
        return { response: t, body: { errors: [{ code: "STRIPE_CLIENT_ERROR", message: "Stripe SCA error", field: "paymentMethod" }] } };
      {
        i.paymentMethod.id || u(s, "paymentMethod", i.paymentMethod.id), u(s, "paymentIntent", c.paymentIntent.id), u(s, "resubmitKey", r.resubmitKey);
        let m = await o(d, { ...a, body: JSON.stringify({ paymentIntent: c.paymentIntent.id, resubmitKey: r.resubmitKey }) }), n = await m.json();
        return { response: m, body: n };
      }
    };
    function E({ body: e, response: t }) {
      return !O(e) && (e == null ? void 0 : e.error) && (e = { errors: [{ message: e.error }] }), { body: e, response: t };
    }
    var U = () => navigator.webdriver || !!document.documentElement.getAttribute(I("d2ViZHJpdmVy")) || !!window.callPhantom || !!window._phantom;
    var h = class {
      constructor() {
        this.loadedAt = w(), this.webdriver = U();
      }
      teardown() {
      }
      data() {
        return { loadedAt: this.loadedAt, webdriver: this.webdriver };
      }
    };
    var y = class {
      constructor(t = {}) {
        this.project = t.project, this.stripePromise = t.stripePromise, typeof window < "u" && this.startBrowserSession();
      }
      startBrowserSession() {
        this.session || (this.session = new h());
      }
      teardown() {
        this.session && this.session.teardown();
      }
      async submitForm(t, r, i = {}) {
        let s = i.endpoint || "https://formspree.io", o = i.fetchImpl || fetch, a = this.project ? `${s}/p/${this.project}/f/${t}` : `${s}/f/${t}`, d = (n) => n instanceof FormData ? n : JSON.stringify(n), c = { Accept: "application/json", "Formspree-Client": P(i.clientName) };
        this.session && (c["Formspree-Session-Data"] = C(this.session.data())), r instanceof FormData || (c["Content-Type"] = "application/json");
        let m = { method: "POST", mode: "cors", body: d(r), headers: c };
        if (this.stripePromise && i.createPaymentMethod) {
          let n = await i.createPaymentMethod();
          if (n.error)
            return { response: null, body: { errors: [{ code: "STRIPE_CLIENT_ERROR", message: "Error creating payment method", field: "paymentMethod" }] } };
          u(r, "paymentMethod", n.paymentMethod.id);
          let f = await o(a, { ...m, body: r }), l = await f.json();
          return l && l.stripe && l.stripe.requiresAction && l.resubmitKey ? await F({ stripePromise: this.stripePromise, responseData: l, response: f, payload: n, data: r, fetchImpl: o, request: m, url: a }) : E({ response: f, body: l });
        } else
          return o(a, m).then((n) => n.json().then((f) => E({ body: f, response: n }))).catch();
      }
    };
    var g = (e) => new y(e);
    var A = () => (S || (S = g()), S);
    var S;
  }
});

// node_modules/@stripe/stripe-js/dist/pure.js
var require_pure = __commonJS({
  "node_modules/@stripe/stripe-js/dist/pure.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var V3_URL = "https://js.stripe.com/v3";
    var V3_URL_REGEX = /^https:\/\/js\.stripe\.com\/v3\/?(\?.*)?$/;
    var EXISTING_SCRIPT_MESSAGE = "loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used";
    var findScript = function findScript2() {
      var scripts = document.querySelectorAll('script[src^="'.concat(V3_URL, '"]'));
      for (var i = 0; i < scripts.length; i++) {
        var script = scripts[i];
        if (!V3_URL_REGEX.test(script.src)) {
          continue;
        }
        return script;
      }
      return null;
    };
    var injectScript = function injectScript2(params) {
      var queryString = params && !params.advancedFraudSignals ? "?advancedFraudSignals=false" : "";
      var script = document.createElement("script");
      script.src = "".concat(V3_URL).concat(queryString);
      var headOrBody = document.head || document.body;
      if (!headOrBody) {
        throw new Error("Expected document.body not to be null. Stripe.js requires a <body> element.");
      }
      headOrBody.appendChild(script);
      return script;
    };
    var registerWrapper = function registerWrapper2(stripe, startTime) {
      if (!stripe || !stripe._registerWrapper) {
        return;
      }
      stripe._registerWrapper({
        name: "stripe-js",
        version: "1.54.0",
        startTime
      });
    };
    var stripePromise2 = null;
    var loadScript = function loadScript2(params) {
      if (stripePromise2 !== null) {
        return stripePromise2;
      }
      stripePromise2 = new Promise(function(resolve, reject) {
        if (typeof window === "undefined" || typeof document === "undefined") {
          resolve(null);
          return;
        }
        if (window.Stripe && params) {
          console.warn(EXISTING_SCRIPT_MESSAGE);
        }
        if (window.Stripe) {
          resolve(window.Stripe);
          return;
        }
        try {
          var script = findScript();
          if (script && params) {
            console.warn(EXISTING_SCRIPT_MESSAGE);
          } else if (!script) {
            script = injectScript(params);
          }
          script.addEventListener("load", function() {
            if (window.Stripe) {
              resolve(window.Stripe);
            } else {
              reject(new Error("Stripe.js not available"));
            }
          });
          script.addEventListener("error", function() {
            reject(new Error("Failed to load Stripe.js"));
          });
        } catch (error) {
          reject(error);
          return;
        }
      });
      return stripePromise2;
    };
    var initStripe = function initStripe2(maybeStripe, args, startTime) {
      if (maybeStripe === null) {
        return null;
      }
      var stripe = maybeStripe.apply(void 0, args);
      registerWrapper(stripe, startTime);
      return stripe;
    };
    var validateLoadParams = function validateLoadParams2(params) {
      var errorMessage = "invalid load parameters; expected object of shape\n\n    {advancedFraudSignals: boolean}\n\nbut received\n\n    ".concat(JSON.stringify(params), "\n");
      if (params === null || _typeof(params) !== "object") {
        throw new Error(errorMessage);
      }
      if (Object.keys(params).length === 1 && typeof params.advancedFraudSignals === "boolean") {
        return params;
      }
      throw new Error(errorMessage);
    };
    var loadParams;
    var loadStripeCalled = false;
    var loadStripe2 = function loadStripe3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      loadStripeCalled = true;
      var startTime = Date.now();
      return loadScript(loadParams).then(function(maybeStripe) {
        return initStripe(maybeStripe, args, startTime);
      });
    };
    loadStripe2.setLoadParameters = function(params) {
      if (loadStripeCalled && loadParams) {
        var validatedParams = validateLoadParams(params);
        var parameterKeys = Object.keys(validatedParams);
        var sameParameters = parameterKeys.reduce(function(previousValue, currentValue) {
          var _loadParams;
          return previousValue && params[currentValue] === ((_loadParams = loadParams) === null || _loadParams === void 0 ? void 0 : _loadParams[currentValue]);
        }, true);
        if (sameParameters) {
          return;
        }
      }
      if (loadStripeCalled) {
        throw new Error("You cannot change load parameters after calling loadStripe");
      }
      loadParams = validateLoadParams(params);
    };
    exports.loadStripe = loadStripe2;
  }
});

// node_modules/@stripe/stripe-js/pure.js
var require_pure2 = __commonJS({
  "node_modules/@stripe/stripe-js/pure.js"(exports, module) {
    module.exports = require_pure();
  }
});

// node_modules/@formspree/react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_core = __toESM(require_dist(), 1);
var import_pure = __toESM(require_pure2(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_core2 = __toESM(require_dist(), 1);
var Elements = (0, import_react.lazy)(
  () => import("./react-stripe.esm-5VJJWZQR.js").then((module) => {
    return { default: module.Elements };
  })
);
var FormspreeContext = import_react.default.createContext({
  client: void 0
});
FormspreeContext.displayName = "Formspree";
var stripePromise;
var getStripe = (stripeKey) => {
  if (!stripePromise) {
    stripePromise = (0, import_pure.loadStripe)(stripeKey);
  }
  return stripePromise;
};
var handleCreateClient = (promise, project) => {
  let config = {};
  if (promise) {
    config.stripePromise = promise;
  }
  if (project) {
    config.project = project;
  }
  return (0, import_core.createClient)(config);
};
var FormspreeProvider = (props) => {
  const [stateStripePromise, setStateStripePromise] = (0, import_react.useState)(void 0);
  const [client, setClient] = (0, import_react.useState)(
    handleCreateClient(stateStripePromise, props.project)
  );
  (0, import_react.useEffect)(() => {
    client.startBrowserSession();
    return () => {
      client.teardown();
    };
  }, []);
  (0, import_react.useEffect)(() => {
    const getStripePromise = async () => {
      const promiseStripe = await getStripe(props.stripePK);
      setStateStripePromise(promiseStripe);
    };
    if (props.stripePK) {
      getStripePromise();
    }
  }, [props.stripePK]);
  (0, import_react.useEffect)(() => {
    if (stateStripePromise) {
      setClient(handleCreateClient(stateStripePromise, props.project));
    }
  }, [stateStripePromise]);
  return import_react.default.createElement(FormspreeContext.Provider, { value: { client } }, props.stripePK ? import_react.default.createElement(import_react.default.Fragment, null, stateStripePromise && import_react.default.createElement(import_react.Suspense, { fallback: import_react.default.createElement("p", null, "....") }, import_react.default.createElement(Elements, { stripe: stateStripePromise }, import_react.default.createElement(import_react.default.Fragment, null, props.children)))) : import_react.default.createElement(import_react.default.Fragment, null, props.children));
};
function useFormspree() {
  const context = (0, import_react.useContext)(FormspreeContext);
  return context.client ? context : {
    client: (0, import_core.getDefaultClient)()
  };
}
var version = "2.4.2";
var isEvent = (data) => {
  return data.preventDefault !== void 0;
};
var useForm = (formKey, args = {}) => {
  const [result, setResult] = (0, import_react2.useState)(null);
  const [submitting, setSubmitting] = (0, import_react2.useState)(false);
  const [succeeded, setSucceeded] = (0, import_react2.useState)(false);
  const [errors, setErrors] = (0, import_react2.useState)([]);
  const formspreeContext = useFormspree();
  const client = args.client || formspreeContext;
  let stripe;
  let elements;
  if (!client) {
    throw new Error("You must provide a Formspree client");
  }
  if (!formKey) {
    throw new Error(
      'You must provide a form key or hashid (e.g. useForm("myForm") or useForm("123xyz")'
    );
  }
  if (formspreeContext.client && formspreeContext.client.stripePromise) {
    stripe = useStripe();
    elements = useElements();
  }
  const debug = !!args.debug;
  let extraData = args.data;
  const reset = () => {
    setSubmitting(false);
    setSucceeded(false);
    setErrors([]);
  };
  const handleSubmit = async (submissionData) => {
    const getFormData = async (event) => {
      event.preventDefault();
      const form = event.target;
      if (form.tagName != "FORM") {
        throw new Error("submit was triggered for a non-form element");
      }
      return new FormData(form);
    };
    let formData = isEvent(submissionData) ? await getFormData(submissionData) : submissionData;
    const appendExtraData = (prop, value) => {
      if (formData instanceof FormData) {
        formData.append(prop, value);
      } else {
        formData = Object.assign(formData, { [prop]: value });
      }
    };
    if (typeof extraData === "object") {
      for (const prop in extraData) {
        let extraDataValue;
        if (typeof extraData[prop] === "function") {
          extraDataValue = extraData[prop].call(null);
          if (typeof (extraDataValue == null ? void 0 : extraDataValue.then) === "function") {
            extraDataValue = await extraDataValue;
          }
        } else {
          extraDataValue = extraData[prop];
        }
        if (extraDataValue !== void 0) {
          appendExtraData(prop, extraDataValue);
        }
      }
    }
    const createPaymentMethod = async () => {
      const address = {
        ...formData.address_line1 && {
          line1: formData.address_line1
        },
        ...formData.address_line2 && {
          line2: formData.address_line2
        },
        ...formData.address_city && {
          city: formData.address_city
        },
        ...formData.address_country && {
          country: formData.address_country
        },
        ...formData.address_state && {
          state: formData.address_state
        },
        ...formData.address_postal_code && {
          postal_code: formData.address_postal_code
        }
      };
      const payload = await stripe.createPaymentMethod({
        type: "card",
        card: elements.getElement(CardElement),
        billing_details: {
          ...formData.name && { name: formData.name },
          ...formData.email && { email: formData.email },
          ...formData.phone && { phone: formData.phone },
          ...address && {
            address
          }
        }
      });
      return payload;
    };
    setSubmitting(true);
    return formspreeContext.client.submitForm(formKey, formData, {
      endpoint: args.endpoint,
      clientName: `@formspree/react@${version}`,
      createPaymentMethod: formspreeContext.client && formspreeContext.client.stripePromise ? createPaymentMethod : void 0
    }).then((result2) => {
      let status = result2.response.status;
      let body;
      if (status === 200) {
        if (debug)
          console.log("Form submitted", result2);
        setSucceeded(true);
        setResult(result2);
        setErrors([]);
      } else if (status >= 400) {
        body = result2.body;
        if (body.errors) {
          setErrors(body.errors);
          if (debug)
            console.log("Error", result2);
        } else {
          setErrors([{ message: "Unexpected error" }]);
          if (debug)
            console.log("Unexpected error", result2);
        }
        setSucceeded(false);
      }
      return result2;
    }).catch((error) => {
      if (debug)
        console.log("Unexpected error", error);
      setSucceeded(false);
      throw error;
    }).finally(() => {
      setSubmitting(false);
    });
  };
  return [{ result, submitting, succeeded, errors }, handleSubmit, reset];
};
var ValidationError = (props) => {
  const { prefix, field, errors, ...attrs } = props;
  const error = (errors || []).find((error2) => {
    return error2.field === field;
  });
  if (!error) {
    return null;
  }
  return import_react3.default.createElement("div", { ...attrs }, prefix, " ", error.message);
};
var export_isFieldError = import_core2.isFieldError;
export {
  CardElement,
  FormspreeProvider,
  ValidationError,
  export_isFieldError as isFieldError,
  useForm,
  useFormspree
};
//# sourceMappingURL=@formspree_react.js.map
